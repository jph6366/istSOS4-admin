#+title: Nitro Nuxt


* Nitro Cache API
- Nitro Cache API is built on top of Unstorage, so it's important to understand how it works before we can dive into Nitro's caching features.

 - wrap any function call with cachedFunction, or we can replace any event handler with defineCachedEventHandler, also use Route Rules configuration in order to wrap our existing event handlers. The cache is stored in Unstorage, so we can use any storage driver we want

 - the cache is stored in memory on production environment, and in .nuxt/cache during development. However, we can configure it to use any storage driver we want.

* [-] BFF (w/ Nuxt, Nitro, and h3)
- why do we need a backend for a frontend design pattern?
  - we can strip all unnecessary content
  - switching out services in BFF that is bound to your application
    - instead of bound to your backend

- how do we fetch data on the frontend (client-side) to strip unnecessary content?
  - we can useFetch() and transform() inside to return desired content from input
    #+begin_src typescript
const { data: user } = await useFetch("https://usersareus.com/users/1", {
    transform(input: any) {
        return {
            id: input.id,
            name: input.name
        }
    }
})
    #+end_src

    **the issue is the original api is still queried and no matter how you transform your data it's still too much and have no control over it**

- to integrate with nitro server we want to write our api handler
  - create server folder and a new API
  /server/api/users/
        /[id].ts/

#+begin_src typescript
export default defineEventHandler(async (event) => {
    const id = getRouterParam(event, 'id')
    if(!id) {
        throw createError({
            statusCode: 400,
            message: 'No ID'
        })
    }

    const result = await $fetch<any>("...")
    return {
        id: input.id,
        name: input.name
    }
})
#+end_src

- you got the backend api at https://.../users/1
  - now all we have to do is fetch the data

#+begin_src typescript
const { data: user } = await useFetch('api/user/1')
#+end_src

- granting type safety

*** Caching in Nitro
here lets start with

#+begin_src typescript
export default defineEventHandler(async (event) => {
    return {
        date: new Date(),
    }
})
#+end_src

/server/api/test.js/

- we want to start with route rules with caching
  - caching thing with SWR and w/o it
    - some max age
      - then complexity

        /nitro.config.ts/
#+begin_src typescript
export default defineNitroConfig({
    srcDir: "server",
    routeRules: {
        '/api/test': {
            cache: {
                maxAge: 10,
                staleMaxAge: 30, // too old
                swr: true // stale-while-revalidate
            }
        }
    }
});
#+end_src

- pretty straightforward after 10s the cache is gones
  - the next request afterwards is the new value

#+begin_src typescript
export default defineEventHandler(async (event) => {
    await new Promise((r) => setTimeout(r, 300))
    return {
        date: new Date(),
    }
})
#+end_src

- after the next 10s the cache is invalidated still
  - cache is expired, TTL is over the max age

- to get new data it has to be awaited
  - but very fresh data

- we can use a stale-while-revalidate technique
  - we give user old data while new data is fetched in the background

- how to tackle this with the Nitro EventHandlers with new function

  - we can scrap nitro config route rules and cache
    #+begin_src typescript
  export default defineCachedEventHandler(async (event) => {
      await new Promise((r) => setTimeout(r, 300))
      return {
          date: new Date(),
      }
  }, {
      maxAge: 10,
      staleMaxAge: 30,
      getKey: () => 'test-cache',
      base: 'cache-important',
//      shouldBypassCache(event) {} // useful for a preview mode
//      shouldInvalidateCache(event) {} //


  })
  #+end_src
- in /handlers/ in /.nitro/.nuxt/ cache folder

- you change where the cache is saved like Redis or SQLite or Parquet, etc.

  - define connection in config
    - choose dev and prod cache server options
#+begin_src typescript
export default defineNitroConfig({
    srcDir:"server",
    storage: {
        'cache-important': {
            driver: 'deno-kv-http'
        }
    },
    devStorage: {
        'cache-important': {
            driver: 'sqlite'
        }
    }
})
#+end_src

- sometimes you don't want to cache the whole event handler
  - or you have a reusable function you want to cache

/server/utils/
        /posts.ts/

#+begin_src typescript
async function getPostsUncached(postNumber: number) {
    return await $fetch('http://.../posts/'+postNumber)
}

export const getPosts = defineCachedFunction(
    (_event: H3Event, postNumber: number) => getPostsUncached(postNumber),
    {
        maxAge: 20,
        // works like defineCachedEventHandler
    }
)
#+end_src

- we can also use await to make sure it doesn't shutdown a runtime instance
  - runtime agnostic code is very useful

- works very similar to CachedEventHandler
  - its in a function
    -that you can reuse in different handlers across nitro backend
    - and have the same cache key
    - and have a smaller scope

we can use it in either EventHandlers

/server/api/
        /posts.ts/

#+begin_src typescript
import { getPosts } from "~/utils/posts.js"

export default defineEventHandler(async (event) => {
    const posts = await getPosts(event, 1)
})

#+end_src
- lots of flexiblity of where to use across the application

- to invalidate certain cache parts we another route

  /server/api/
        /invalidate.ts/

#+begin_src typescript
export default defineEventHandler(async (event) => {
    const cacheStorage = useStorage('cache')
    //cache-key => invalidate the entry
    const key = 'nitro:handlers:_:testcache.json'
    const hasItem = await cacheStorage.hasItem(key)
    if(hasItem) {
        await cacheStorage.removeItem(key)
    }
    return {
        hasItem: await cacheStorage.hasItem(key)
    }
})
#+end_src

- we can pass in name or group into the CachedEventHandler to assign specific identifier
  - otherwise it will default to _ underscore

- the cache key is setup
  - how can we remove things?
    - through useStorage


**** Stale-While-Revalidate
- helps developers balance between immediacy and freshness
  - loading cached content right away
  - ensuring updates to the cached content are used in the future

**a cached response might be stale, and the process of revalidation**

1. if a locally cached response is still fresh then its used as-is
2. if the cached response is stale, another age-based check is performed
   - is the age of the cached response w/in additional time windows
     - provided by the stale-while-revalidate setting?
   - if the age of a stale response falls w/in this window
     - then it will be used to fullfill the request
       - at the same time, a revalidation request will be made
         - against the network in a way that doesn't delay the use of the cached response
   - the returned response might contain the same information as the previously cached response, or be different
     - the network response is stored locally either way
       - replacing whatever was previous cache
         - resetting freshness timer for max age comparisons

   - if the stale cached response is too old and outside of window
     - it will not fulfill request
     - browser will retrieve a response from the network and use that
       - for both local cache and initial request
         - with a fresh response


*** Using BFF for Caching in Nitro
- You can add your application specific utils inside server/utils/ directory and they will be auto-imported when used. Every export in the utils directory and its subdirectories will become available globally in your application.

- lets say in our server folder we have /server/api/user/utils/
                                                        /users.ts/
  #+begin_src typescript
import type { H3Event }  from 'h3'
export const getUser = defineCachedFunction((_event: H3Event, id:string) => {

    const result = await $fetch<any>("...")
    return {
        id: input.id,
        name: input.name
    }

});
  #+end_src

  - we can update our [id].ts event handler
    - we create a function that is caching the whole API call and transformation

  #+begin_src typescript
export default defineEventHandler(async (event) => {
    const id = getRouterParam(event, 'id')
    if(!id) {
        throw createError({
            statusCode: 400,
            message: 'No ID'
        })
    }

    const user = await getUser(event, id)

    return user
})
  #+end_src

  - lastly we want to set up our cached function

#+begin_src typescript
import type { H3Event }  from 'h3'
export const getUser = defineCachedFunction(_event: H3Event, id:string) => {

    const result = await $fetch<any>("...")
    return {
        id: input.id,
        name: input.name
    }
}. {
    swr: false,
    maxAge: 1000
};

// then we can do more with the data

export async function getRecentUsers(): Promise<any[]> {
    const users = await useStorage().getItem<any[]>(KEY)
    return users
}

export async function addRecentUser(user: any) {
    ...
}
#+end_src

- update event handler to cache BFF data

#+begin_src typescript


const user = await getUser(event, id)
await addRecentUser(user)

return user

#+end_src

*** [-] Fetch Once and Share Data between Nuxt and Nitro
- build a basic endpoint in server folder

  /server/middleware/ab-test.js/
- The server middleware in Nuxt 3 is always called on every incoming request to the server
  - even if the page doesn't use useFetch() or call an API.
    - It runs before any route or API handler,
      - so it's great for logging, auth checks, and other global logic.


  #+begin_src typescript
export default defineEventHandler(async (event) => {
    const variant = Math.random() < 0.5 ? 'A' : 'B'
    const abTestInfo = {
        variant,
        data: await fetchSomeData(variant)
        }
    })

function fetchSomeData(variant: 'A' | 'B') {
    if (variant === 'A'){
        return {
            message: 'It Was A'
        }
    }
    return {
        message: 'It was B'
    }
}


  #+end_src

  - anything you need in your backend to already prepare the request of that user to be successful
    - sometimes we need this in our frontend as well

  - put it all in an API endpoint and refetch it in the nuxt frontend
    - the request will not go through the whole round trip
      - nitro will de-duplicate it and say this is to my server
        - the event handler function specifies



  #+begin_src typescript

export default defineEventHandler(async (event) => {
    const variant = Math.random() < 0.5 ? 'A' : 'B'
    const abTestInfo = {
        variant,
        data: await fetchSomeData(variant)
        }

    event.context.abTestInfo = abTestInfo // per-request state

})

function fetchSomeData(variant: 'A' | 'B') {
    if (variant === 'A'){
        return {
            message: 'It Was A'
        }
    }
    return {
        message: 'It was B'
    }
}

  #+end_src

- lets type our per-request state
  - we add *.d.ts in server folder

/server/env.d.ts/
- declare h3, http nitro framework
  - interface h3 event context
    - we can augment types here
#+begin_src typescript
declare module 'h3' {
    interface H3EventContext {
        abTestInfo: {
            variant: 'A' | 'B',
            data: Record<string, string>
        }
    }
}

export {} // actually applies the whole augment



...

// we need to apply a variant type to TS errors
   const variant: 'A' | 'B' = Math.random() < 0.5 ? 'A' : 'B'
#+end_src

- no we want to make it available to nuxt
  - we use a plugin
  - we also want to make it accessible on the frontend
    - we useState

  /plugins/ab-test.js/

#+begin_src typescript
export default defineNuxtPlugin({
    name: 'ab-test',
    async setup() {
//        const abTestData = useState('ab-test') // changed to composable
        const abTestData = useAbTest()
        // read out event context
        if(import.meta.server){
            //const event = useRequestEvent() // h3 event available
            const event = useRequestEvent()!
//            event?.context.abTestInfo
            abTestData.value = event.context.abTestInfo!

        }
    }
})
#+end_src

- when this plugin is executed on the client-side
  - the useState will still be populated because on the server-side its populated
    - and as its transferred from the server to client, its available there

- we should just make it composable straight away if we want to use it in our components

/composables/useAbTest.js/

#+begin_src typescript
export const useAbTest = () => useState('ab-test')
#+end_src

- in app.vue

   #+begin_src html
<script setup lang="ts">
  const data = useAbTest()
</script>

<template>
  <pre>
    {{ data  }}
  </pre>
</template>
   #+end_src





* SensorThings API Provider as a BFF

- OGC SensorThings API provides an open, geospatial-enabled and unified way to interconnect the IoT devices, data, and applications over the web.

- OGC SensorThings is a RESTful API
  - GET
    - get index, all of type, one of type, linked entity, all linked entities
  - POST
    - create type, create linked entity
  - PATCH/DELETE
    - update one of type, delete one of type

- the main difference between the OGC Sensor Observation Service and the OGC Sensor Planning Service, and the SensorThings API is that the API is designed for resource-constrained IoT devices and the web developer commmunity
  - REST principles
  - JSON encoding
  - MQTT protocol
  - OASIS OData Protocol and URL conventions

- the entity control information, resource path usages, query options, the relevant JSON encodings, and batch-processing request follow OData 4.0
  - SensorThings API does not follow OData's metadata service model or Common Schema Definition Language


_Terms and Defns_
- _Collection_, set of resources, retrievable partially or wholly
- _Entity_, instances of SensorThings entity types
- _Entity Sets_, named collections of entities
  - unique key identifies entity within an entity set
    - provides entry points into _OGC STA API Service_
- _Internet of Things_, a thing is an object of the physical world (physical things) or the information world (virtual things) that is capable of being identified and integrated into communication networks
- _Measurement_, a set of operations having the object of determining the value of a quantity.
- _Observation_, determining the value of a property
- _Resource_, a network-accessible data object or service identified by an URI
- _REST_, Representational State Transfer, an abstraction of architectural elements within a distributed hypermedia system
  - essence of its behavior as a network-based application encompassing the fundamental constraints upon components, connectors, and data that define the basis of the Web architecture
- _Sensor_, an entity capable of observing a phenomenom and returning an observed value
  - type of observation procedure that provides the estimated value of an observed property at its output

** Common Control Information
- In SensorThings control information is represented  as annotations whose names start with iot followed by a dot (.)
  - Annotations are name/value pairs that have a dot as part of the name

_when annotating a name/value pair_
1. for which the value is represented as JSON object
  - the name always starts with @
  - followed by namspace iot
  - followed by a dot
  - followed by the name of the term
(e.g., "@iot.id":1)
1. for which the value is represented as a JSON array or primitive value
   - each annotation that applies to this name/value pair is placed next to the annotated name/value pair and represented as a single pair
     - the name is the same as the name of the name/value pair being annotated
     - followed by the @
     - followed by namespace iot
     - followed by a dot
     - followed by the name of the term
(e.g., "Locations@iot.navigationLink":"http://example.org/v1.1/Things(1)/Locations" )

** URI Components
- OGC SensorThings API services expose service documents that describe its data model
  - the service document lists the entity sets that can be CRUD
  - SenorThings API clients can use the service document to navigate the available entities in a hypermedia-driven fashion

- a service groups the same types of entities into an entity set
- in the case of an entity holding a relationship with entities in other entity sets
  - this type of relationship is expression with navigation properties
(i.e., navigationLink and associationLink)

_to perform CRUD actions on resources_
you must address the target resource(s) through URI

1. the service root URI
   - consists of two parts
     - location of Sensorthings service and version number
2. the resource path
3. the query options

http://example.org/v1.1/

Observations

?$orderby=ID&$top=10



**  istSOS SensorThings API
- istSOS4 is an OGC SensorThings API compliant service implementation with enabled reproducibility of processes thanks to the Traveltime extension.
  - the extension assists istSOS users in accessing historical time travel data. https://istsos.org/foss4g-asia/tutorial/traveltime/

- in istSOS4 users have specific roles which define their access permissions.
  1. admin
     all PRIVILEGES on all tables

  2. viewer
     SELECT privilege on all tables

  3. editor
     SELECT privilege on all tables INSERT, UPDATE, DELETE privileges on all tables (expect User table)

  4. obs_manager
     SELECT privilege on all tables
     INSERT, UPDATE, DELETE privileges on Observation table
     INSERT privilege on FeaturesOfInterest table
     UPDATE privilege on Datastream table

  5. sensor
     SELECT privilege on all tables
     INSERT privilege on Observation and FeaturesOfInterest tables
     UPDATE privilege on Datastream table

- the password flow is defined for OAuth2, to handle security and authentication
  - which in istSOS's case the same application handles the API and authentication
  - We can add other flows such as openid connect, which we can link OpenStreetMaps OAuth provider for basic user read-only activities
